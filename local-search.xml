<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>loss不下降怎么办</title>
    <link href="/2025/03/27/loss%E4%B8%8D%E4%B8%8B%E9%99%8D%E6%80%8E%E4%B9%88%E5%8A%9E/"/>
    <url>/2025/03/27/loss%E4%B8%8D%E4%B8%8B%E9%99%8D%E6%80%8E%E4%B9%88%E5%8A%9E/</url>
    
    <content type="html"><![CDATA[<h1>Loss不下降怎么办</h1><p>在训练神经网络时，如果发现 Loss 长时间不下降，可以从以下两个方面进行检查。</p><h2 id="1-检查参数设置">1. 检查参数设置</h2><ul><li><strong>学习率（Learning Rate）是否合适</strong>：<ul><li>过大可能导致 Loss 震荡甚至发散。</li><li>过小可能导致收敛速度过慢甚至停滞。</li><li>观察 Loss 变化趋势，并尝试调整学习率。</li></ul></li><li><strong>优化器（Optimizer）设置</strong>：<ul><li>是否正确初始化优化器？</li><li>是否正确使用 <code>zero_grad()</code> 清除梯度？</li><li>是否尝试了不同的优化器（AdamW、SGD 等）？</li></ul></li><li><strong>Batch Size 影响</strong>：<ul><li>过小的 batch size 可能导致梯度噪声较大。</li><li>过大的 batch size 可能导致泛化能力下降。</li><li>适当调整 batch size 观察效果。</li></ul></li><li><strong>数据是否正确</strong>：<ul><li>目标值范围是否正确？</li><li>是否存在数据泄漏？</li><li>归一化或标准化是否一致？</li></ul></li></ul><h2 id="2-检查-Grad-和计算图">2. 检查 Grad 和计算图</h2><ul><li><strong>梯度是否正确计算</strong>：<ul><li>通过 <code>on_after_backward()</code> 或 <code>on_before_optimizer_step()</code> 检查参数的梯度是否为 <code>None</code>。</li><li>可能原因：参数未注册、未计算梯度或梯度被截断。</li></ul></li><li><strong>输入是否有 <code>requires_grad=True</code></strong><ul><li>使用 <code>input.requires_grad</code> 检查输入是否可计算梯度。</li><li>如果 <code>requires_grad=False</code>，则反向传播不会计算梯度。</li></ul></li><li><strong>检查梯度是否过大或过小（Lightning PyTorch）</strong><ul><li>在 <code>on_after_backward()</code> 里打印梯度范数：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">on_after_backward</span>(<span class="hljs-params">self</span>):</span><br>    <span class="hljs-keyword">for</span> name, param <span class="hljs-keyword">in</span> self.named_parameters():<br>        <span class="hljs-keyword">if</span> param.grad <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>            self.log(<span class="hljs-string">f&quot;grad_norm/<span class="hljs-subst">&#123;name&#125;</span>&quot;</span>, param.grad.norm())<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Layer <span class="hljs-subst">&#123;name&#125;</span> | Grad Norm: <span class="hljs-subst">&#123;param.grad.norm().item()&#125;</span>&quot;</span>)<br></code></pre></td></tr></table></figure></li><li>观察是否存在梯度爆炸（梯度过大）或梯度消失（梯度趋近于 0）。</li></ul></li><li><strong>计算图是否正确构建</strong><ul><li>确保 <code>loss</code> 依赖于所有参数，否则 <code>loss.backward()</code> 不会正确计算梯度。</li><li>检查 <code>loss.requires_grad</code> 是否为 <code>True</code>。</li><li>确保没有错误使用 <code>.detach()</code> 或 <code>torch.no_grad()</code>，否则会截断梯度。</li></ul></li></ul><h2 id="3-其他可能原因">3. 其他可能原因</h2><ul><li><strong>梯度裁剪（Gradient Clipping）</strong><ul><li>在梯度爆炸时使用 <code>self.clip_gradients(optimizer, gradient_clip_val=1.0)</code> 进行裁剪。</li></ul></li><li><strong>检查是否正确使用 <code>manual_backward()</code>（Lightning）</strong><ul><li>仅在 <code>automatic_optimization=False</code> 时，才需要手动调用 <code>manual_backward(loss)</code>。</li></ul></li></ul><p>如果按照这些步骤排查，应该能找到 Loss 不下降的原因并加以修正。</p>]]></content>
    
    
    <categories>
      
      <category>code</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>如何解压缩大文件</title>
    <link href="/2025/03/27/%E5%A6%82%E4%BD%95%E8%A7%A3%E5%8E%8B%E7%BC%A9%E5%A4%A7%E6%96%87%E4%BB%B6/"/>
    <url>/2025/03/27/%E5%A6%82%E4%BD%95%E8%A7%A3%E5%8E%8B%E7%BC%A9%E5%A4%A7%E6%96%87%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<h2 id="如何解压大文件">如何解压大文件</h2><h3 id="常见解压方式及优化">1. <strong>常见解压方式及优化</strong></h3><h4 id="使用-7z-解压"><strong>使用 <code>7z</code> 解压</strong></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">7z x file.zip -ooutput_dir -mmt=48<br></code></pre></td></tr></table></figure><ul><li><code>-mmt=48</code>：使用 48 线程（根据 CPU 核心数调整）。</li><li><code>-ooutput_dir</code>：指定输出目录。</li></ul><p><strong>续解压（跳过已解压文件）</strong> 7z x file.zip -ooutput_dir-aos -mmt=48</p><h4 id="使用-unzip"><strong>使用 <code>unzip</code></strong></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">unzip file.zip -d output_dir<br></code></pre></td></tr></table></figure><ul><li><code>-d output_dir</code>：解压到指定目录。</li></ul><p><strong>继续上次的解压</strong> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">unzip -n file.zip -d output_dir<br></code></pre></td></tr></table></figure> -<code>-d output_dir</code>：解压到指定目录。 -<code>-n</code>：避免覆盖已有文件，加快解压。 - #### <strong>使用<code>tar</code>（适用于 <code>.tar.gz</code> 或<code>.tar.bz2</code>）</strong> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">tar -xvf file.tar.gz -C output_dir<br></code></pre></td></tr></table></figure> -<code>-x</code>：解压，<code>-v</code>：显示进度，<code>-f</code>：指定文件。</p><h4 id="使用-pigz多线程-gzip"><strong>使用 <code>pigz</code>（多线程gzip）</strong></h4><p>如果 <code>.zip</code> 里是 <code>.gz</code> 文件，换<code>pigz</code> 可加速： <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">pigz -dc file.gz | tar xvf -<br></code></pre></td></tr></table></figure></p><h3 id="检查解压进度">2. <strong>检查解压进度</strong></h3><h4 id="方法-1使用-pv-监控进度"><strong>方法 1：使用 <code>pv</code>监控进度</strong></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">pv file.zip | unzip -d output_dir<br></code></pre></td></tr></table></figure><h4 id="方法-2使用-iotop-或-dstat-监控-io"><strong>方法 2：使用<code>iotop</code> 或 <code>dstat</code> 监控 I/O</strong></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">iotop  <span class="hljs-comment"># 监控磁盘读写</span><br></code></pre></td></tr></table></figure><h3 id="提高解压速度的方法">3. <strong>提高解压速度的方法</strong></h3><h4 id="增加解压并行度"><strong>（1）增加解压并行度</strong></h4><ul><li><code>7z</code> 默认支持多线程，使用 <code>-mmt=N</code>来增加线程数。</li><li><code>tar</code> 解压 <code>.tar.gz</code> 时可以用<code>pigz</code> 提高速度。</li></ul><h4 id="调整-io-优先级"><strong>（2）调整 I/O 优先级</strong></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ionice -c 2 -n 0 unzip file.zip -d output_dir<br></code></pre></td></tr></table></figure><ul><li><code>-c 2</code>：后台模式，<code>-n 0</code> 最高优先级。</li></ul><h4 id="清理缓存加速-io"><strong>（3）清理缓存，加速 I/O</strong></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> 3 | sudo tee /proc/sys/vm/drop_caches<br></code></pre></td></tr></table></figure><h3 id="如何断点续解">4. <strong>如何断点续解</strong></h3><p>如果解压中断，可以使用： <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">7z x file.zip -ooutput_dir -aos<br></code></pre></td></tr></table></figure> -<code>-aos</code>：跳过已解压的文件，避免重复解压。</p><p>或者使用 <code>rsync</code> 进行增量同步： <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">rsync -av --ignore-existing <span class="hljs-built_in">source</span>/ destination/<br></code></pre></td></tr></table></figure></p><h3 id="如何检查解压是否正确">5.<strong>如何检查解压是否正确</strong></h3><h4 id="使用-diff-或-md5sum-对比原始文件"><strong>使用 <code>diff</code>或 <code>md5sum</code> 对比原始文件</strong></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">diff -r output_dir original_files_dir<br>md5sum file.zip &gt; checksum.txt<br>md5sum -c checksum.txt<br></code></pre></td></tr></table></figure><h4 id="使用-7z-校验完整性"><strong>使用 <code>7z</code>校验完整性</strong></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">7z t file.zip<br></code></pre></td></tr></table></figure><ul><li><code>t</code> 选项可检测 <code>.zip</code> 文件是否损坏。</li></ul><h3 id="解决卡顿问题">6. <strong>解决卡顿问题</strong></h3><p>如果 <code>iotop</code> 显示磁盘写入很低，可能是 <strong>I/O调度问题</strong>： <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo renice -n -5 -p $(pgrep unzip)<br></code></pre></td></tr></table></figure> - 提高 <code>unzip</code>进程的优先级。</p><p>如果 <strong>CPU 占用高</strong>，可能是<strong>单线程瓶颈</strong>，可以尝试： <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">unzip -n file.zip -d output_dir &amp;<br></code></pre></td></tr></table></figure> -<code>&amp;</code> 让解压在后台运行，减少主线程负担。</p><hr /><h2 id="结论">结论</h2><ul><li><strong>使用 <code>7z</code> 和 <code>unzip -n</code></strong>避免重复解压。</li><li><strong>使用 <code>-mmt=48</code> 增加线程数</strong>提高速度。</li><li><strong>监控 I/O (<code>iotop</code>) 识别瓶颈</strong>。</li><li><strong>使用 <code>7z t</code> 或 <code>md5sum</code>校验完整性</strong>。</li><li><strong>断点续解：使用 <code>7z -aos</code> 或<code>rsync</code></strong>。</li></ul><p>通过这些方法，可以更快、更安全地解压大文件。</p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OTTER:A Vision-Language-Action Model with Text-Aware Visual Feature Extraction</title>
    <link href="/2025/03/06/2025-3/paper4/"/>
    <url>/2025/03/06/2025-3/paper4/</url>
    
    <content type="html"><![CDATA[<h3 id="ottera-vision-language-action-model-with-text-aware-visual-feature-extraction">OTTER:A Vision-Language-Action Model with Text-Aware Visual Feature Extraction</h3><p>加强VLA对语言的理解能力</p><img src="/2025/03/06/2025-3/paper4/image.png" class=""><p>A simple but efficient method</p><img src="/2025/03/06/2025-3/paper4/image-1.png" class=""><img src="/2025/03/06/2025-3/paper4/image-2.png" class="">]]></content>
    
    
    <categories>
      
      <category>AI-Paper-Reading</category>
      
      <category>Robot</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Robot</tag>
      
      <tag>VLA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Improving Vision-Language-Action Model with Online Reinforcement Learning</title>
    <link href="/2025/03/06/2025-3/paper3/"/>
    <url>/2025/03/06/2025-3/paper3/</url>
    
    <content type="html"><![CDATA[<p>arxiv链接：</p><p>https://arxiv.org/pdf/2501.16664</p><h2 id="improving-vision-language-action-model-with-online-reinforcement-learning">Improving Vision-Language-Action Model with Online Reinforcement Learning</h2><img src="/2025/03/06/2025-3/paper3/image.png" class=""><p>总结：使用RL finetune VLM 不稳定，这里感觉参考了replay buffer的想法，分为两步，先用RL 收集数据，只训action head，然后再用成功轨迹去finetune VLM, backbone 和action head都训练.</p><img src="/2025/03/06/2025-3/paper3/image-1.png" class=""><p>只用ppo replay效果不好， 结果： <img src="/2025/03/06/2025-3/paper3/image-2.png" class=""></p>]]></content>
    
    
    <categories>
      
      <category>AI-Paper-Reading</category>
      
      <category>Robot</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Robot</tag>
      
      <tag>Rl</tag>
      
      <tag>VLA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Fine-Tuning Vision-Language-Action Models:Optimizing Speed and Success</title>
    <link href="/2025/03/04/2025-3/paper2/"/>
    <url>/2025/03/04/2025-3/paper2/</url>
    
    <content type="html"><![CDATA[<p>https://openvla-oft.github.io</p><h2id="fine-tuning-vision-language-action-models-optimizing-speed-and-success">Fine-TuningVision-Language-Action Models: Optimizing Speed and Success</h2><p>Stanford <img src="/2025/03/04/2025-3/paper2/image.png" class=""></p><p>Summary:This paper explores how to fine-tune VLA model better, andthey propose Open VLA OFT(Optimized Fine-Tuning) based on Open VLA whichcontains parallel decoding action chunking and a continuous actionrepresentation, and a simple L1 regression -base learning object toimprove performance and inference efficiency.</p><img src="/2025/03/04/2025-3/paper2/image-1.png" class=""><p>Parallel decoding:. We modify the model to receive empty actionembeddings as input and replace the causal attention mask withbidirectional attention, allowing the decoder to predict all actionssimultaneously.</p><p>Action policy: Discrete action tokens is not better than continuousaction policy. The author think that may because the discrete actionlose more details. L1 regression is simple and efficient just like myexperimental experience.</p><p>FiLM: they also found that the policy struggle with languagefollowing due to spurious correlations in visual inputs, so they useFiLM(https://arxiv.org/abs/1709.07871)which infuse language embeddingsinto the visual representation so that the model can pay more attentionto language inputs.</p><img src="/2025/03/04/2025-3/paper2/image-2.png" class=""><p>This result is consistent with my experiment findings: third image isenough to get a good performance.</p><p>Real robot experiment:</p><img src="/2025/03/04/2025-3/paper2/image-3.png" class="">]]></content>
    
    
    <categories>
      
      <category>AI-Paper-Reading</category>
      
      <category>Robot</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Robot</tag>
      
      <tag>VLA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Paper Reading:Generalist World Model Pre-Training for Efficient Reinforcement Learning</title>
    <link href="/2025/03/04/2025-3/paper1/"/>
    <url>/2025/03/04/2025-3/paper1/</url>
    
    <content type="html"><![CDATA[<p>arxiv: https://arxiv.org/pdf/2502.19544v1</p><p>time：2025.2.26 ### Paper Reading:Generalist World Model Pre-Training for Efficient Reinforcement Learning</p><p>作者：</p><img src="/2025/03/04/2025-3/paper1/image.png" class=""><p>Summary: This paper specially consider reward-free and non-expert multi-embodiment offline data, and use a world model pre-Training WPT to guide the RL fine-tuning.</p><p>Emphasize the generalization of this method.</p><img src="/2025/03/04/2025-3/paper1/image-1.png" class=""><p>The experience rehearsal and execution guidance can generate useful initial state and guide the policy to collect the data closed to the offline data distribution in fine-tuning.</p><p>Result:</p><img src="/2025/03/04/2025-3/paper1/image-2.png" class=""><p>It makes the method converge faster, but its success rate is not higher than other offline learning methods.</p>]]></content>
    
    
    <categories>
      
      <category>AI-Paper-Reading</category>
      
      <category>RL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>RL</tag>
      
      <tag>Robot</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>linux常用命令</title>
    <link href="/2021/12/21/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <url>/2021/12/21/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<h2 id="python">Python</h2><p><code>type -a python3</code></p><p>查看所有python3安装目录</p><p><code>which python</code></p><p>查看当前使用的是哪里的python</p><h2 id="tmux使用方法">tmux使用方法</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs sh">tmux ls<br><br>tmux new -s &lt; name&gt;<br><br>tmux attach -t &lt; name&gt;/&lt; number&gt;<br><br>tmux switch -t &lt; name &gt;/&lt; number &gt;<br><br>tmux detach<br><br>Ctrl+b d：分离当前会话。<br><br>Ctrl+b s：列出所有会话。<br><br>Ctrl+b $：重命名当前会话<br></code></pre></td></tr></table></figure><h2 id="ipdb操作">ipdb操作：</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs sh">ipdb.set_trace()<br><br>python -m ipdb your_code.py<br><br>下一条语句<br>使用n(next)执行下一条语句<br><br>进入函数内部<br>使用s(step into)进入函数调用的内部。<br><br>b line_number<br><br>b file_name:line_number<br><br>一直执行直到遇到下一个断点<br><br>使用c(<span class="hljs-built_in">continue</span>)执行代码直到遇到某个断点或程序执行完毕。<br><br>一直执行直到返回<br>使用r(<span class="hljs-built_in">return</span>)执行代码直到当前所在的这个函数返回。<br><br>跳过某段代码<br>使用j line_number(jump)可以跳过某段代码，直接执行指定行号所在的代码。<br>更多上下文<br><br>在IPDB调试环境中，默认只显示当前执行的代码行，以及其上下各一行的代码。如果想要看到更多的上下文代码，可以使用l first[, second](list)命令。<br><br>其中first指示向上最多显示的行号，second指示向下最多显示的行号（可以省略）。当second小于first时，second指的是从first开始的向下的行数（相对值vs绝对值）<br><br>我在哪里<br>w<br>调试兴起，可能你会忘了自己目前所在的行号。例如在打印了若干变量值后，屏幕完全被这些值占据。使用w或者<span class="hljs-built_in">where</span>可以打印出目前所在的行号位置以及上下文信息。<br><br>这是啥<br>我们可以使用whatis variable_name的方法，查看变量的类别（感觉有点鸡肋，用<span class="hljs-built_in">type</span>也可以办到）。<br><br>当你身处一个函数内部的时候，可以使用a(argument)打印出传入函数的所有参数的值。<br><br>使用p(<span class="hljs-built_in">print</span>)和pp(pretty <span class="hljs-built_in">print</span>)可以打印表达式的值。<br><br>使用cl或者clear file:line_number清除断点。如果没有参数，则清除所有断点。<br><br>使用restart重新启动调试器，断点等信息都会保留。restart实际是run的别名，使用run args的方式传入参数。<br><br>使用q退出调试，并清除所有信息。<br></code></pre></td></tr></table></figure><h2 id="screen">screen</h2><p>screen是一个可以在多个进程（通常是交互式shell）之间复用一个物理终端的全屏幕窗口管理器。即linux下使用多窗口</p><p>常用screen参数</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs sh">screen -S session_name  <br><br>新建一个叫session_name的session<br><br>screen -ls（或者screen -list） <br><br>列出当前所有的session<br><br>screen -r session_name  <br><br>回到session_name这个session<br><br>screen -d session_name   <br><br>远程detach某个session<br><br>screen -d -r session_name      <br><br>结束当前session并回到session_name这个session<br><br>滑动窗口：<br>Ctrl + a + [<br>h -    Move the cursor left by one character<br>j -    Move the cursor down by one line<br>k -    Move the cursor up by one line<br>l -    Move the cursor right by one character<br>0 -    Move to the beginning of the current line<br>$ -    Move to the end of the current line.<br>G -    Moves to the specified line<br>       (defaults to the end of the buffer).<br>C-u -  Scrolls a half page up.<br>C-b -  Scrolls a full page up.<br>C-d -  Scrolls a half page down.<br>C-f -  Scrolls the full page down.<br><br>进入screen窗口后，想暂时退出（等会还想连接这个screen窗口）<br>crtl+a+d<br><br>退出当前screen窗口，结束当前screen窗口，不想再连接回来（即杀死会话）<br><span class="hljs-built_in">exit</span>或者ctrl+d<br></code></pre></td></tr></table></figure><p>top查看谁在用程序</p><h2 id="pytorch配置">pytorch配置</h2><p>下载hydra-0.11 python setup.py install pip install gym tensorboard</p><p>pip3 install --pre torch torchvision torchaudio -f https://download.pytorch.org/whl/nightly/cu111/torch_nightly.html</p><p>conda install pytorch-1.8.0-py3.8_cuda11.1_cudnn8.0.5_0.tar.bz2</p><p>conda clean --all</p><p>pip install torchvison==0.9.0</p><p>permute(dims)</p><p>将tensor的维度换位。</p><h2 id="pytorch的nn.linear详解">PyTorch的nn.Linear（）详解:</h2><p>nn.linear(in_features,out_features,bias=True)</p><p>in_features指的是输入的二维张量的大小，即输入的[batch_size, size]中的size。 size = channel * height * width out_features指的是输出的二维张量的大小</p><p>在使用前需要把数据view一下，四维变二维 x = x.view(x.size[0],-1)</p><p>torch.distributions.Categorical 对某个array进行分类，输出的是类别的分布</p><h2 id="服务器本地传文件">服务器本地传文件：</h2><p>ssh root@194.165.1.203 -p 2222 #指定端口登录 scp <本地文件名> -p 端口号 <用户名>@<ssh服务器地址>:<上传保存路径即文件名></p><p>查看文件大小du -h --max-depth=1 your_dest_dir</p><h2 id="vscode-缩进">vscode 缩进：</h2><p>command [ command ]</p><h2 id="有关vscode崩坏的解决">有关vscode崩坏的解决：</h2><p>从 https://update.code.visualstudio.com/commit:${commit_id}/server-linux-x64/stable 下载 vs code server</p><p>3866c3553be8b268c8a7f8c0482c0c0177aa8bfa https://update.code.visualstudio.com/commit:e7d7e9a9348e6a8cc8c03f877d39cb72e5dfb1ff/server-linux-x64/stable</p><p>${commit_id}替换为当前电脑id 379476f0e13988d90fab105c5c19e7abc8b1dea8</p><p>scp 传输到 vscode-server/bin/下</p><p>将远程的.vscode文件删除并重新连接可得到该id</p><p>cd /root/.vscode-server/bin/379476f0e13988d90fab105c5c19e7abc8b1dea8</p><p>mv vscode-server-linux-x64.tar vscode-server.tar.gz touch vscode-scp-done.flag</p><p>mv vscode-server-linux-x64.tar.gz vscode-server.tar.gz</p><p>然后再连接就可以了。</p><p>又踩坑了，注意从谷歌下载该压缩包，大小大概为50m</p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hellow world</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>pytorch+mujoco</title>
    <link href="/2021/12/21/pytorch%E5%9D%91+mujoco%E9%85%8D%E7%BD%AE/"/>
    <url>/2021/12/21/pytorch%E5%9D%91+mujoco%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<h2 id="section"></h2><h2 id="pytoch部分坑和理解">pytoch部分坑和理解</h2><p>1，torch.tensor重建 2，torch的卷机操作和线性操作都不能够改变batch那一部分 3，对于两个不同的model进行顺序处理和使用不同的optim时，需要先同时进行backward操作在进行，optimize.step操作 4，对于此样系统而言：relu操作可能会造成数据的inplace，注意使用clone操作还有relu的（replace = false） 5, 不能直接取tensor的一部分会变成list。所以要使用函数torch的操作</p><p>torch.sub <span class="math display">\[torch.sub(input, other,*,alpha=1,out=None)--&gt;Tensor\\Subtracts other, scaled by alpha, from input.\\out_i = input_i - alpha \times other_i\]</span></p><h2 id="单例singleton">单例（Singleton）</h2><p>单例是一种<strong>设计模式</strong>，应用该模式的类只会生成一个实例。</p><p>单例模式保证了在程序的不同位置都<strong>可以且仅可以取到同一个对象实例</strong>：如果实例不存在，会创建一个实例；如果已存在就会返回这个实例。因为单例是一个类，所以你也可以为其提供相应的操作方法，以便于对这个实例进行管理。</p><p>Pytorch 实现代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">singleton</span>(<span class="hljs-params">cls</span>):</span><br>    _instance = &#123;&#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">inner</span>():</span><br>        <span class="hljs-keyword">if</span> cls <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> _instance:<br>            _instance[cls] = cls()<br>        <span class="hljs-keyword">return</span> _instance[cls]<br>    <span class="hljs-keyword">return</span> inner<br>    <br><span class="hljs-meta">@singleton</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cls</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">pass</span><br><br>cls1 = Cls()<br>cls2 = Cls()<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">id</span>(cls1) == <span class="hljs-built_in">id</span>(cls2))<br></code></pre></td></tr></table></figure><h2 id="mujoco环境配置">MuJoCo环境配置：</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 使用yml配置conda env</span><br>conda env create -f environment.yml<br><br><span class="hljs-comment"># 下载mujoco200</span><br><br><span class="hljs-comment"># 放到.mujoco</span><br><br>unzip mujoco200_linux.zip<br><br><span class="hljs-comment"># 改名为mujoco200</span><br><br>wget https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/Anaconda3-2020.11-Linux-x86_64.sh  --no-check-certificate<br><br>sh Anaconda3-2020.11-Linux-x86_64.sh<br><br>conda env create -f conda_env.yml<br><br>pip install scipy==1.5.0<br><br>pip install termcolor==1.1.0 tb-nightly imageio==2.9.0 imageio-ffmpeg==0.4.4 hydra-core==1.1.0 hydra-submitit-launcher==1.1.5<br><br>pip install pandas==1.3.0 ipdb==0.13.9 yapf==0.31.0 sklearn==0.0 matplotlib==3.4.2 opencv-python==4.5.3.56<br><br>pip install dm_control<br><br>pip install mujoco_py==2.0.2.13<br><br>pip install lxml==4.5.2<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hellow world</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>博客搭建</title>
    <link href="/2021/12/21/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
    <url>/2021/12/21/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[<p>搭建个人博客mac版</p><h1 id="大纲">大纲</h1><p>搭建博客主要分为三个部分，执行可以无先后之分。</p><p>分别是：</p><p>1，环境配置Hexo</p><p>2，部署到github上</p><p>3，绑定域名</p><p>个人建议先绑定域名，因为实名认证以及域名解析认证需要花费3-5天时间。</p><p>三者的关系是，域名作为入口，hexo创建门面，github储存内容。因此，他们需要相互连接才能建成最后的博客，hexo首先创建博客，然后推送到github上进行存储，github连接域名，使得访问者可以看到你的博客。</p><h2 id="hexo">Hexo</h2><p>简洁高效的博客框架，可自己下载主题</p><p>官网：https://hexo.io/zh-cn/</p><p>安装Hexo前需要安装Git</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 检查git是否安装</span><br>git --version<br><span class="hljs-comment"># 没安装就安装 </span><br>brew install git<br></code></pre></td></tr></table></figure><p>在mac上我们通过brew来安装：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sh">brew install node<br><span class="hljs-comment"># 安装过程中可能出现bug,显示不能安装node的依赖libuv，那么就手动安装 brew install libuv</span><br><span class="hljs-comment"># 查看版本号</span><br>node -v<br><span class="hljs-comment"># 查看npm版本号 没有就安装</span><br>npm -v<br><span class="hljs-comment"># 安装 hexo</span><br>npm install -g hexo-cli<br></code></pre></td></tr></table></figure><p>创建文件夹：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 首先cd 到你想要保存的路径当中</span><br><span class="hljs-comment">#查看当前路径</span><br><span class="hljs-built_in">pwd</span><br><span class="hljs-comment">#查看当前文件夹下的文件</span><br>ls<br><span class="hljs-comment">#创建文件夹</span><br>mkdir blog<br><span class="hljs-built_in">cd</span> blog<br><span class="hljs-comment"># 初始化</span><br>hexo init<br><span class="hljs-comment"># 启动 s:start</span><br>hexo s<br>浏览器输入：http://localhost:4000，可查看到默认生成了一篇博文<br>新建一篇博文<br>hexo n <span class="hljs-string">&quot;hellow&quot;</span><br><span class="hljs-comment"># 清理</span><br>hexo clean<br><span class="hljs-comment">#生成</span><br>hexo g<br>hexo s<br></code></pre></td></tr></table></figure><h2 id="github-部署">Github 部署</h2><p>git新建一个仓库，具体新建步骤建议参考网上教程</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 安装git部署插件</span><br>npm install hexo-deployer-git --save<br></code></pre></td></tr></table></figure><p>修改_config.yml的配置</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh">deploy:<br>  <span class="hljs-built_in">type</span>: git<br>  repo: https://github.com/你的git名字.github.io.git<br>  branch: master<br></code></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">回到命令行部署到远端<br>hexo d<br></code></pre></td></tr></table></figure><h2 id="域名申请">域名申请</h2><p>首先需要在阿里云申请域名 <a href="https://www.aliyun.com/ss/?k=域名">https://www.aliyun.com/ss/?k=%E5%9F%9F%E5%90%8D</a></p><p>注册阿里云，</p><h3 id="解析域名">解析域名</h3><p>打开阿里云首页 控制台-&gt;域名-&gt;域名列表-&gt;解析</p><p>此处可能没有记录类型，默认的记录类型为A，因此记录值需要填写ip地址。可以在terminal中 ping 你的github名称.github.io，就能得到ip地址，生成解析文件后再进行修改即可。</p><p>设置主机记录@，记录类型为CNAME，记录值是”你的github名称.github.io“。 设置主机记录www，记录类型为CNAME，记录值是”你的github名称.github.io“</p><h3 id="部署到github上">部署到GitHub上</h3><p>在blog/source中添加文件CNAME</p><p>并写入你的域名如: asdf.com</p><p>接着回到blog/publish的终端：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh">hexo clean<br>hexo g<br>hexo d<br></code></pre></td></tr></table></figure><p>可能遇到的错误： “The authenticity of host ‘github.com’ can’t be established”：这表明你正在连接 GitHub 的服务器时，系统无法确认其身份 “Permission denied (publickey)”：这个错误表明 Git 无法通过 SSH 密钥进行身份验证。 解决方案：添加SSH密钥</p><ol type="1"><li><p>启动 SSH 代理： <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">eval</span> <span class="hljs-string">&quot;<span class="hljs-subst">$(ssh-agent -s)</span>&quot;</span><br></code></pre></td></tr></table></figure></p></li><li><p>添加 SSH 密钥到代理： 使用下面的命令添加密钥（如果你使用的是默认的密钥文件 ~/.ssh/id_rsa）：</p></li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">ssh-add ~/.ssh/id_rsa<br></code></pre></td></tr></table></figure><pre><code class="hljs">3.  验证 SSH 密钥是否添加成功：</code></pre><p>运行以下命令，确认密钥是否已正确添加到代理中：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">ssh-add -l<br></code></pre></td></tr></table></figure><p>如果看到类似 2048 SHA256:xxxxxx 的输出，表示密钥已成功加载。</p><ol type="1"><li>检查 GitHub 是否添加了 SSH 公钥</li></ol><p>如果你还没有将 SSH 公钥添加到 GitHub，可以按照以下步骤进行添加： 1. 查看本地公钥： 打开终端，运行以下命令查看 SSH 公钥： <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">cat ~/.ssh/id_rsa.pub<br></code></pre></td></tr></table></figure> 复制输出的内容。</p><pre><code class="hljs">2.  将公钥添加到 GitHub：1.  登录到你的 GitHub 账户。2.  进入 Settings → SSH and GPG keys → New SSH key。3.  粘贴公钥内容并保存。</code></pre><ol start="3" type="1"><li>测试 SSH 连接</li></ol><p>可以通过以下命令测试 SSH 是否能够正确连接到 GitHub：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">ssh -T git@github.com<br></code></pre></td></tr></table></figure><p>如果连接成功，你应该会看到如下消息：</p><p>Hi <username>! You've successfully authenticated, but GitHub does not provide shell access.</p><p>如果你看到类似的消息，就说明 SSH 配置已经正确。</p><ol start="4" type="1"><li>确保 Git 远程 URL 正确</li></ol><p>请确保远程仓库的 URL 是通过 SSH 配置的，而不是 HTTPS。你可以使用以下命令查看当前的远程 URL 配置： <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">git remote -v<br></code></pre></td></tr></table></figure> 如果看到的 URL 是类似 https://github.com/yourname/yourname.github.io.git，请按照以下命令将其更改为 SSH URL： <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">git remote set-url origin git@github.com:yourname/yourname.github.io.git<br></code></pre></td></tr></table></figure> 5. 重新尝试推送代码</p><p>如果上述步骤都已经完成，可以尝试重新执行 git push： <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">hexo d<br></code></pre></td></tr></table></figure></p><p><img src="https://github.com/Artimisu/artimis.github.io/blob/master/mdimg/a1.png?raw=true-2021122200261" style="zoom:50%;" /></p><h2 id="域名备案">域名备案</h2><p>到阿里云主页，最上一栏的右边有ICP备案，根据教程走即可。</p><h2 id="hexo扩展设置">Hexo扩展设置</h2><p>首先，梳理一下关系：page生成页面，config文件设置页面，source存储文件内容。page生成的页面需要使用config来设置属性，而config中的资源调配需要符合source中存储的文件名称。</p><p>_config.yml文件用于设置博客的内容类型，比如颜色高度，名称等等，以及使用的图像链接来源。</p><p>总文件夹下和每个themes文件夹下都有相应的_config.yml。</p><p>source中存储文章内容以及所需图像。</p><p>博客中的每个链接都是一个page，比如”关于我“的页面等等，可以通过hexo new page "page 名称"来生成，生成完之后会在source中出现一个文件夹，里面有index.md的文件，编辑这个文件就是编辑该页面的内容。该page的设置在你的themes的_config.yml进行设置。</p><p>至于config文件到底怎么设置，可以去hexo上下载喜欢的主题，解压到themes当中。</p><p>接着在blog路径下的config文件中将theme一栏改为需要使用的theme文件夹名称，一般theme中的config文件都有注释，应该看看就明白了。</p><h2 id="hexo-问题">hexo 问题：</h2><p>1，如何在自己的页面中添加图像并让其显示显示折叠 <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">hexo new page yourpage<br></code></pre></td></tr></table></figure> 解决方法：通过markdown语法进行添加</p><p>打开source 中yourpage目录中的index.md添加 示例：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sh">&lt;details&gt;<br>  &lt;summary&gt;2025 年 3 月&lt;/summary&gt;<br><br>  &lt;ul&gt;<br>    &lt;li&gt;&lt;a href=<span class="hljs-string">&quot;/2025/03/04/2025-3/paper1/&quot;</span>&gt;paper1&lt;/a&gt;&lt;/li&gt;<br>    &lt;li&gt;&lt;a href=<span class="hljs-string">&quot;/2025/03/04/2025-3/paper2/&quot;</span>&gt;paper2&lt;/a&gt;&lt;/li&gt;<br>  &lt;/ul&gt;<br><br>&lt;/details&gt;<br></code></pre></td></tr></table></figure><p>/2025/03/04/2025-3/paper1/ 必须跟post文件的生成链接相同，可以通过hexo s命令后生成的网页找到该文件的链接：http://localhost:4000/2025/03/04/2025-3/paper1/ 提取http://localhost:4000 后的链接即为我们需要的href，paper1这个名字可以自己随便改</p><p>2，如何正确显示图像</p><p>显示图像现在用的插件是hexo-asset-img</p><p>安装：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">npm install hexo-asset-img --save<br></code></pre></td></tr></table></figure><p>配置： 打开source下面的_config.yml文件</p><p>post_asset_folder 设置为 true</p><p>添加：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh">asset_image:<br>  <span class="hljs-built_in">enable</span>: <span class="hljs-literal">true</span>  <span class="hljs-comment"># 启用图片处理插件</span><br>  folder: <span class="hljs-built_in">source</span>/images  <span class="hljs-comment"># 确保图片存放路径正确</span><br>  url: /images  <span class="hljs-comment"># 图片 URL 配置</span><br></code></pre></td></tr></table></figure><p>hexo-asset-img注意点1：</p><p>原理：hexo-asset-img的作用其实是在publish里面生成正确的html文件，即将正确的图像路径插入到html文件中，同时把图像copy到publish文件夹当中。</p><p>因此，你生成的时候最好使用hexo new post yourpostname这个命令，因为它会在_post文件夹下生成一个文件，yourpostname.md, 以及一个文件夹 yourpostname 用来存放图像，这种格式是必须的，如果你自己在_post下新建文件，则必须新建一个跟其同名的文件夹，不然hexo-asset-img这个插件找不到你的image，就无法在publish里面生成正确的html文件，也不会把图像copy过去，图像就无法显示。</p><p>在hexo-asset-img没报错的情况下，如何判断你的publish里面有没有正确生成图像和链接：</p><p>去publish文件里面，一般文件都会在在年月日文件夹下面,如2025/03/04/，看看里面有没有图像，或者找到该文件夹之后，执行：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">ls -R public/2025/03/04/<br></code></pre></td></tr></table></figure><p>看看里面有没有图片，没有很可能就是你的文件存放格式错了，而不是hexo-asset-img的问题</p><p>还可以再去public/2025/03/04/下面的yourpostname/index.html文件中找</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">&lt;img src= <br></code></pre></td></tr></table></figure><p>看看后面的图像名称路径对不对，正常来说应该只有一个imgae_name.png，而没有相对路径和绝对路径</p><p>hexo-asset-img注意点1： 当前vscode中的markdown已经不需要插件就支持直接粘贴图像，为了配合hexo-asset-img，我们需要设置它的参数</p><p>找到vscode左下角的设置图标，或者快捷键</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">Windows/Linux：Ctrl + ,<br>Mac：Cmd + ,<br></code></pre></td></tr></table></figure><p>搜索：</p><p>markdown.copyFiles.destination</p><p>添加项</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">项：**/*<br>值：<span class="hljs-variable">$&#123;documentBaseName&#125;</span>/<br></code></pre></td></tr></table></figure><p>项代表你要粘贴的文件格式，**/* 代表匹配所有文件，通常为图片</p><p>值代码你想要粘贴到哪个路径下，在这里设置为md文件的同名文件夹下</p><p>想要生成子文件夹下的post <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">hexo new post -p folder_name/yourpostname<br></code></pre></td></tr></table></figure></p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hellow world</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2021/12/21/hello-world/"/>
    <url>/2021/12/21/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="quick-start">Quick Start</h2><h3 id="create-a-new-post">Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="run-server">Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="generate-static-files">Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="deploy-to-remote-sites">Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
